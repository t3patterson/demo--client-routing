{"version":3,"sources":["webpack:///js/bundle.js","webpack:///webpack/bootstrap 6a2ee9dae6859546eac2","webpack:///./src/scripts/app.js","webpack:///./~/director/build/director.js","webpack:///./src/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_director","renderHomeTemplate","txt","document","querySelector","innerHTML","renderStep1","console","log","renderStep2","render404","routes","/step-1","/step-2","/","/*","routerInstance","Router","setRoute","getRoute","init","dlocHashEmpty","dloc","hash","_every","arr","iterator","length","_flatten","flat","concat","_asyncEverySeries","callback","completed","iterate","err","paramifyString","str","params","mod","param","regifyString","matches","last","out","substr","match","index","replace","capture","captures","slice","terminator","delimiter","start","stop","left","right","toString","chunk","indexOf","join","location","listener","mode","history","check","h","this","onHashChanged","fire","window","onpopstate","onhashchange","fn","onchange","onChangeEvent","listeners","self","undefined","documentMode","setTimeout","frame","createElement","id","style","display","body","appendChild","writeFrame","attachEvent","event","propertyName","setInterval","push","destroy","splice","setHash","pushState","title","f","getElementById","contentDocument","contentWindow","open","write","close","syncHash","_hash","methods","scope","_methods","_insert","insert","insertEx","historySupport","configure","mount","r","routeTo","handler","newURL","url","getPath","dispatch","charAt","convert_hash_in_init","replaceState","run_in_init","explode","v","split","val","method","path","route","parent","once","apply","arguments","ret","pathname","QUERY_SEPARATOR","options","recurse","async","strict","notfound","resource","html5history","run_handler_in_init","every","after","before","on","token","matcher","compiled","RegExp","source","Array","isArray","forEach","toLowerCase","routesFn","updateAndInvoke","fns","invoke","runlist","traverse","invoked","_invoked","reverse","thisArg","next","regexp","filter","filterRoutes","deepCopy","result","applyFilter","newRoutes","matched","current","exact","Boolean","parentType","nested","part","shift","test","Error","extend","extra","len","insertOrMount","local","rename","parts","routeType","isRoute","_interopRequireDefault","obj","default","_main","_app","hostname","linkEl","removeChild"],"mappings":"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","file":"./js/bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _director = __webpack_require__(2);\n\nvar renderHomeTemplate = function renderHomeTemplate(txt) {\n  document.querySelector('#app-container').innerHTML = '\\n      <h1>How to draw an owl</h1>\\n      <p>A step by step guide how to draw an owl</p>\\n      <footer>\\n        <a href=\"#/step-1\">&#10095;</a>\\n      </footer>\\n    ';\n};\n\nvar renderStep1 = function renderStep1(txt) {\n  console.log(\"????\");\n  document.querySelector('#app-container').innerHTML = '\\n        <h1>Step 1</h1>\\n        <p>Draw some circles</p>\\n        <img src=\"/images/step-1.png\"/>\\n        <footer>\\n          <a href=\"#/step-2\">&#10095;</a>\\n        </footer>\\n      ';\n};\n\nvar renderStep2 = function renderStep2(txt) {\n  document.querySelector('#app-container').innerHTML = '\\n      <h1>Step 2</h1>\\n      <p>Draw the rest of the fucking owl</p>\\n      <img src=\"/images/step-2.png\"/>\\n      <footer>\\n        <a href=\"/\">&#10095;</a>\\n      </footer>\\n    ';\n};\n\nvar render404 = function render404(txt) {\n  document.querySelector('#app-container').innerHTML = '\\n      <h1 class=\"error-page\">Sorry</h1>\\n      <p>That page doesn\\'t exist</p>\\n      <footer>\\n        <a href=\"/\">&#10224;</a>\\n      </footer>\\n    ';\n};\n\nvar routes = {\n  '/step-1': renderStep1,\n  '/step-2': renderStep2,\n  '/': renderHomeTemplate,\n  '/*': render404\n\n  /*Routing */\n};var routerInstance = (0, _director.Router)(routes);\nrouterInstance.setRoute(routerInstance.getRoute());\nrouterInstance.init('/');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n//\n// Generated on Tue Dec 16 2014 12:13:47 GMT+0100 (CET) by Charlie Robbins, Paolo Fragomeni & the Contributors (Using Codesurgeon).\n// Version 1.2.6\n//\n\n(function (exports) {\n\n/*\n * browser.js: Browser specific functionality for director.\n *\n * (C) 2011, Charlie Robbins, Paolo Fragomeni, & the Contributors.\n * MIT LICENSE\n *\n */\n\nvar dloc = document.location;\n\nfunction dlocHashEmpty() {\n  // Non-IE browsers return '' when the address bar shows '#'; Director's logic\n  // assumes both mean empty.\n  return dloc.hash === '' || dloc.hash === '#';\n}\n\nvar listener = {\n  mode: 'modern',\n  hash: dloc.hash,\n  history: false,\n\n  check: function () {\n    var h = dloc.hash;\n    if (h != this.hash) {\n      this.hash = h;\n      this.onHashChanged();\n    }\n  },\n\n  fire: function () {\n    if (this.mode === 'modern') {\n      this.history === true ? window.onpopstate() : window.onhashchange();\n    }\n    else {\n      this.onHashChanged();\n    }\n  },\n\n  init: function (fn, history) {\n    var self = this;\n    this.history = history;\n\n    if (!Router.listeners) {\n      Router.listeners = [];\n    }\n\n    function onchange(onChangeEvent) {\n      for (var i = 0, l = Router.listeners.length; i < l; i++) {\n        Router.listeners[i](onChangeEvent);\n      }\n    }\n\n    //note IE8 is being counted as 'modern' because it has the hashchange event\n    if ('onhashchange' in window && (document.documentMode === undefined\n      || document.documentMode > 7)) {\n      // At least for now HTML5 history is available for 'modern' browsers only\n      if (this.history === true) {\n        // There is an old bug in Chrome that causes onpopstate to fire even\n        // upon initial page load. Since the handler is run manually in init(),\n        // this would cause Chrome to run it twise. Currently the only\n        // workaround seems to be to set the handler after the initial page load\n        // http://code.google.com/p/chromium/issues/detail?id=63040\n        setTimeout(function() {\n          window.onpopstate = onchange;\n        }, 500);\n      }\n      else {\n        window.onhashchange = onchange;\n      }\n      this.mode = 'modern';\n    }\n    else {\n      //\n      // IE support, based on a concept by Erik Arvidson ...\n      //\n      var frame = document.createElement('iframe');\n      frame.id = 'state-frame';\n      frame.style.display = 'none';\n      document.body.appendChild(frame);\n      this.writeFrame('');\n\n      if ('onpropertychange' in document && 'attachEvent' in document) {\n        document.attachEvent('onpropertychange', function () {\n          if (event.propertyName === 'location') {\n            self.check();\n          }\n        });\n      }\n\n      window.setInterval(function () { self.check(); }, 50);\n\n      this.onHashChanged = onchange;\n      this.mode = 'legacy';\n    }\n\n    Router.listeners.push(fn);\n\n    return this.mode;\n  },\n\n  destroy: function (fn) {\n    if (!Router || !Router.listeners) {\n      return;\n    }\n\n    var listeners = Router.listeners;\n\n    for (var i = listeners.length - 1; i >= 0; i--) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1);\n      }\n    }\n  },\n\n  setHash: function (s) {\n    // Mozilla always adds an entry to the history\n    if (this.mode === 'legacy') {\n      this.writeFrame(s);\n    }\n\n    if (this.history === true) {\n      window.history.pushState({}, document.title, s);\n      // Fire an onpopstate event manually since pushing does not obviously\n      // trigger the pop event.\n      this.fire();\n    } else {\n      dloc.hash = (s[0] === '/') ? s : '/' + s;\n    }\n    return this;\n  },\n\n  writeFrame: function (s) {\n    // IE support...\n    var f = document.getElementById('state-frame');\n    var d = f.contentDocument || f.contentWindow.document;\n    d.open();\n    d.write(\"<script>_hash = '\" + s + \"'; onload = parent.listener.syncHash;<script>\");\n    d.close();\n  },\n\n  syncHash: function () {\n    // IE support...\n    var s = this._hash;\n    if (s != dloc.hash) {\n      dloc.hash = s;\n    }\n    return this;\n  },\n\n  onHashChanged: function () {}\n};\n\nvar Router = exports.Router = function (routes) {\n  if (!(this instanceof Router)) return new Router(routes);\n\n  this.params   = {};\n  this.routes   = {};\n  this.methods  = ['on', 'once', 'after', 'before'];\n  this.scope    = [];\n  this._methods = {};\n\n  this._insert = this.insert;\n  this.insert = this.insertEx;\n\n  this.historySupport = (window.history != null ? window.history.pushState : null) != null\n\n  this.configure();\n  this.mount(routes || {});\n};\n\nRouter.prototype.init = function (r) {\n  var self = this\n    , routeTo;\n  this.handler = function(onChangeEvent) {\n    var newURL = onChangeEvent && onChangeEvent.newURL || window.location.hash;\n    var url = self.history === true ? self.getPath() : newURL.replace(/.*#/, '');\n    self.dispatch('on', url.charAt(0) === '/' ? url : '/' + url);\n  };\n\n  listener.init(this.handler, this.history);\n\n  if (this.history === false) {\n    if (dlocHashEmpty() && r) {\n      dloc.hash = r;\n    } else if (!dlocHashEmpty()) {\n      self.dispatch('on', '/' + dloc.hash.replace(/^(#\\/|#|\\/)/, ''));\n    }\n  }\n  else {\n    if (this.convert_hash_in_init) {\n      // Use hash as route\n      routeTo = dlocHashEmpty() && r ? r : !dlocHashEmpty() ? dloc.hash.replace(/^#/, '') : null;\n      if (routeTo) {\n        window.history.replaceState({}, document.title, routeTo);\n      }\n    }\n    else {\n      // Use canonical url\n      routeTo = this.getPath();\n    }\n\n    // Router has been initialized, but due to the chrome bug it will not\n    // yet actually route HTML5 history state changes. Thus, decide if should route.\n    if (routeTo || this.run_in_init === true) {\n      this.handler();\n    }\n  }\n\n  return this;\n};\n\nRouter.prototype.explode = function () {\n  var v = this.history === true ? this.getPath() : dloc.hash;\n  if (v.charAt(1) === '/') { v=v.slice(1) }\n  return v.slice(1, v.length).split(\"/\");\n};\n\nRouter.prototype.setRoute = function (i, v, val) {\n  var url = this.explode();\n\n  if (typeof i === 'number' && typeof v === 'string') {\n    url[i] = v;\n  }\n  else if (typeof val === 'string') {\n    url.splice(i, v, s);\n  }\n  else {\n    url = [i];\n  }\n\n  listener.setHash(url.join('/'));\n  return url;\n};\n\n//\n// ### function insertEx(method, path, route, parent)\n// #### @method {string} Method to insert the specific `route`.\n// #### @path {Array} Parsed path to insert the `route` at.\n// #### @route {Array|function} Route handlers to insert.\n// #### @parent {Object} **Optional** Parent \"routes\" to insert into.\n// insert a callback that will only occur once per the matched route.\n//\nRouter.prototype.insertEx = function(method, path, route, parent) {\n  if (method === \"once\") {\n    method = \"on\";\n    route = function(route) {\n      var once = false;\n      return function() {\n        if (once) return;\n        once = true;\n        return route.apply(this, arguments);\n      };\n    }(route);\n  }\n  return this._insert(method, path, route, parent);\n};\n\nRouter.prototype.getRoute = function (v) {\n  var ret = v;\n\n  if (typeof v === \"number\") {\n    ret = this.explode()[v];\n  }\n  else if (typeof v === \"string\"){\n    var h = this.explode();\n    ret = h.indexOf(v);\n  }\n  else {\n    ret = this.explode();\n  }\n\n  return ret;\n};\n\nRouter.prototype.destroy = function () {\n  listener.destroy(this.handler);\n  return this;\n};\n\nRouter.prototype.getPath = function () {\n  var path = window.location.pathname;\n  if (path.substr(0, 1) !== '/') {\n    path = '/' + path;\n  }\n  return path;\n};\nfunction _every(arr, iterator) {\n  for (var i = 0; i < arr.length; i += 1) {\n    if (iterator(arr[i], i, arr) === false) {\n      return;\n    }\n  }\n}\n\nfunction _flatten(arr) {\n  var flat = [];\n  for (var i = 0, n = arr.length; i < n; i++) {\n    flat = flat.concat(arr[i]);\n  }\n  return flat;\n}\n\nfunction _asyncEverySeries(arr, iterator, callback) {\n  if (!arr.length) {\n    return callback();\n  }\n  var completed = 0;\n  (function iterate() {\n    iterator(arr[completed], function(err) {\n      if (err || err === false) {\n        callback(err);\n        callback = function() {};\n      } else {\n        completed += 1;\n        if (completed === arr.length) {\n          callback();\n        } else {\n          iterate();\n        }\n      }\n    });\n  })();\n}\n\nfunction paramifyString(str, params, mod) {\n  mod = str;\n  for (var param in params) {\n    if (params.hasOwnProperty(param)) {\n      mod = params[param](str);\n      if (mod !== str) {\n        break;\n      }\n    }\n  }\n  return mod === str ? \"([._a-zA-Z0-9-%()]+)\" : mod;\n}\n\nfunction regifyString(str, params) {\n  var matches, last = 0, out = \"\";\n  while (matches = str.substr(last).match(/[^\\w\\d\\- %@&]*\\*[^\\w\\d\\- %@&]*/)) {\n    last = matches.index + matches[0].length;\n    matches[0] = matches[0].replace(/^\\*/, \"([_.()!\\\\ %@&a-zA-Z0-9-]+)\");\n    out += str.substr(0, matches.index) + matches[0];\n  }\n  str = out += str.substr(last);\n  var captures = str.match(/:([^\\/]+)/ig), capture, length;\n  if (captures) {\n    length = captures.length;\n    for (var i = 0; i < length; i++) {\n      capture = captures[i];\n      if (capture.slice(0, 2) === \"::\") {\n        str = capture.slice(1);\n      } else {\n        str = str.replace(capture, paramifyString(capture, params));\n      }\n    }\n  }\n  return str;\n}\n\nfunction terminator(routes, delimiter, start, stop) {\n  var last = 0, left = 0, right = 0, start = (start || \"(\").toString(), stop = (stop || \")\").toString(), i;\n  for (i = 0; i < routes.length; i++) {\n    var chunk = routes[i];\n    if (chunk.indexOf(start, last) > chunk.indexOf(stop, last) || ~chunk.indexOf(start, last) && !~chunk.indexOf(stop, last) || !~chunk.indexOf(start, last) && ~chunk.indexOf(stop, last)) {\n      left = chunk.indexOf(start, last);\n      right = chunk.indexOf(stop, last);\n      if (~left && !~right || !~left && ~right) {\n        var tmp = routes.slice(0, (i || 1) + 1).join(delimiter);\n        routes = [ tmp ].concat(routes.slice((i || 1) + 1));\n      }\n      last = (right > left ? right : left) + 1;\n      i = 0;\n    } else {\n      last = 0;\n    }\n  }\n  return routes;\n}\n\nvar QUERY_SEPARATOR = /\\?.*/;\n\nRouter.prototype.configure = function(options) {\n  options = options || {};\n  for (var i = 0; i < this.methods.length; i++) {\n    this._methods[this.methods[i]] = true;\n  }\n  this.recurse = options.recurse || this.recurse || false;\n  this.async = options.async || false;\n  this.delimiter = options.delimiter || \"/\";\n  this.strict = typeof options.strict === \"undefined\" ? true : options.strict;\n  this.notfound = options.notfound;\n  this.resource = options.resource;\n  this.history = options.html5history && this.historySupport || false;\n  this.run_in_init = this.history === true && options.run_handler_in_init !== false;\n  this.convert_hash_in_init = this.history === true && options.convert_hash_in_init !== false;\n  this.every = {\n    after: options.after || null,\n    before: options.before || null,\n    on: options.on || null\n  };\n  return this;\n};\n\nRouter.prototype.param = function(token, matcher) {\n  if (token[0] !== \":\") {\n    token = \":\" + token;\n  }\n  var compiled = new RegExp(token, \"g\");\n  this.params[token] = function(str) {\n    return str.replace(compiled, matcher.source || matcher);\n  };\n  return this;\n};\n\nRouter.prototype.on = Router.prototype.route = function(method, path, route) {\n  var self = this;\n  if (!route && typeof path == \"function\") {\n    route = path;\n    path = method;\n    method = \"on\";\n  }\n  if (Array.isArray(path)) {\n    return path.forEach(function(p) {\n      self.on(method, p, route);\n    });\n  }\n  if (path.source) {\n    path = path.source.replace(/\\\\\\//ig, \"/\");\n  }\n  if (Array.isArray(method)) {\n    return method.forEach(function(m) {\n      self.on(m.toLowerCase(), path, route);\n    });\n  }\n  path = path.split(new RegExp(this.delimiter));\n  path = terminator(path, this.delimiter);\n  this.insert(method, this.scope.concat(path), route);\n};\n\nRouter.prototype.path = function(path, routesFn) {\n  var self = this, length = this.scope.length;\n  if (path.source) {\n    path = path.source.replace(/\\\\\\//ig, \"/\");\n  }\n  path = path.split(new RegExp(this.delimiter));\n  path = terminator(path, this.delimiter);\n  this.scope = this.scope.concat(path);\n  routesFn.call(this, this);\n  this.scope.splice(length, path.length);\n};\n\nRouter.prototype.dispatch = function(method, path, callback) {\n  var self = this, fns = this.traverse(method, path.replace(QUERY_SEPARATOR, \"\"), this.routes, \"\"), invoked = this._invoked, after;\n  this._invoked = true;\n  if (!fns || fns.length === 0) {\n    this.last = [];\n    if (typeof this.notfound === \"function\") {\n      this.invoke([ this.notfound ], {\n        method: method,\n        path: path\n      }, callback);\n    }\n    return false;\n  }\n  if (this.recurse === \"forward\") {\n    fns = fns.reverse();\n  }\n  function updateAndInvoke() {\n    self.last = fns.after;\n    self.invoke(self.runlist(fns), self, callback);\n  }\n  after = this.every && this.every.after ? [ this.every.after ].concat(this.last) : [ this.last ];\n  if (after && after.length > 0 && invoked) {\n    if (this.async) {\n      this.invoke(after, this, updateAndInvoke);\n    } else {\n      this.invoke(after, this);\n      updateAndInvoke();\n    }\n    return true;\n  }\n  updateAndInvoke();\n  return true;\n};\n\nRouter.prototype.invoke = function(fns, thisArg, callback) {\n  var self = this;\n  var apply;\n  if (this.async) {\n    apply = function(fn, next) {\n      if (Array.isArray(fn)) {\n        return _asyncEverySeries(fn, apply, next);\n      } else if (typeof fn == \"function\") {\n        fn.apply(thisArg, (fns.captures || []).concat(next));\n      }\n    };\n    _asyncEverySeries(fns, apply, function() {\n      if (callback) {\n        callback.apply(thisArg, arguments);\n      }\n    });\n  } else {\n    apply = function(fn) {\n      if (Array.isArray(fn)) {\n        return _every(fn, apply);\n      } else if (typeof fn === \"function\") {\n        return fn.apply(thisArg, fns.captures || []);\n      } else if (typeof fn === \"string\" && self.resource) {\n        self.resource[fn].apply(thisArg, fns.captures || []);\n      }\n    };\n    _every(fns, apply);\n  }\n};\n\nRouter.prototype.traverse = function(method, path, routes, regexp, filter) {\n  var fns = [], current, exact, match, next, that;\n  function filterRoutes(routes) {\n    if (!filter) {\n      return routes;\n    }\n    function deepCopy(source) {\n      var result = [];\n      for (var i = 0; i < source.length; i++) {\n        result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];\n      }\n      return result;\n    }\n    function applyFilter(fns) {\n      for (var i = fns.length - 1; i >= 0; i--) {\n        if (Array.isArray(fns[i])) {\n          applyFilter(fns[i]);\n          if (fns[i].length === 0) {\n            fns.splice(i, 1);\n          }\n        } else {\n          if (!filter(fns[i])) {\n            fns.splice(i, 1);\n          }\n        }\n      }\n    }\n    var newRoutes = deepCopy(routes);\n    newRoutes.matched = routes.matched;\n    newRoutes.captures = routes.captures;\n    newRoutes.after = routes.after.filter(filter);\n    applyFilter(newRoutes);\n    return newRoutes;\n  }\n  if (path === this.delimiter && routes[method]) {\n    next = [ [ routes.before, routes[method] ].filter(Boolean) ];\n    next.after = [ routes.after ].filter(Boolean);\n    next.matched = true;\n    next.captures = [];\n    return filterRoutes(next);\n  }\n  for (var r in routes) {\n    if (routes.hasOwnProperty(r) && (!this._methods[r] || this._methods[r] && typeof routes[r] === \"object\" && !Array.isArray(routes[r]))) {\n      current = exact = regexp + this.delimiter + r;\n      if (!this.strict) {\n        exact += \"[\" + this.delimiter + \"]?\";\n      }\n      match = path.match(new RegExp(\"^\" + exact));\n      if (!match) {\n        continue;\n      }\n      if (match[0] && match[0] == path && routes[r][method]) {\n        next = [ [ routes[r].before, routes[r][method] ].filter(Boolean) ];\n        next.after = [ routes[r].after ].filter(Boolean);\n        next.matched = true;\n        next.captures = match.slice(1);\n        if (this.recurse && routes === this.routes) {\n          next.push([ routes.before, routes.on ].filter(Boolean));\n          next.after = next.after.concat([ routes.after ].filter(Boolean));\n        }\n        return filterRoutes(next);\n      }\n      next = this.traverse(method, path, routes[r], current);\n      if (next.matched) {\n        if (next.length > 0) {\n          fns = fns.concat(next);\n        }\n        if (this.recurse) {\n          fns.push([ routes[r].before, routes[r].on ].filter(Boolean));\n          next.after = next.after.concat([ routes[r].after ].filter(Boolean));\n          if (routes === this.routes) {\n            fns.push([ routes[\"before\"], routes[\"on\"] ].filter(Boolean));\n            next.after = next.after.concat([ routes[\"after\"] ].filter(Boolean));\n          }\n        }\n        fns.matched = true;\n        fns.captures = next.captures;\n        fns.after = next.after;\n        return filterRoutes(fns);\n      }\n    }\n  }\n  return false;\n};\n\nRouter.prototype.insert = function(method, path, route, parent) {\n  var methodType, parentType, isArray, nested, part;\n  path = path.filter(function(p) {\n    return p && p.length > 0;\n  });\n  parent = parent || this.routes;\n  part = path.shift();\n  if (/\\:|\\*/.test(part) && !/\\\\d|\\\\w/.test(part)) {\n    part = regifyString(part, this.params);\n  }\n  if (path.length > 0) {\n    parent[part] = parent[part] || {};\n    return this.insert(method, path, route, parent[part]);\n  }\n  if (!part && !path.length && parent === this.routes) {\n    methodType = typeof parent[method];\n    switch (methodType) {\n     case \"function\":\n      parent[method] = [ parent[method], route ];\n      return;\n     case \"object\":\n      parent[method].push(route);\n      return;\n     case \"undefined\":\n      parent[method] = route;\n      return;\n    }\n    return;\n  }\n  parentType = typeof parent[part];\n  isArray = Array.isArray(parent[part]);\n  if (parent[part] && !isArray && parentType == \"object\") {\n    methodType = typeof parent[part][method];\n    switch (methodType) {\n     case \"function\":\n      parent[part][method] = [ parent[part][method], route ];\n      return;\n     case \"object\":\n      parent[part][method].push(route);\n      return;\n     case \"undefined\":\n      parent[part][method] = route;\n      return;\n    }\n  } else if (parentType == \"undefined\") {\n    nested = {};\n    nested[method] = route;\n    parent[part] = nested;\n    return;\n  }\n  throw new Error(\"Invalid route context: \" + parentType);\n};\n\n\n\nRouter.prototype.extend = function(methods) {\n  var self = this, len = methods.length, i;\n  function extend(method) {\n    self._methods[method] = true;\n    self[method] = function() {\n      var extra = arguments.length === 1 ? [ method, \"\" ] : [ method ];\n      self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));\n    };\n  }\n  for (i = 0; i < len; i++) {\n    extend(methods[i]);\n  }\n};\n\nRouter.prototype.runlist = function(fns) {\n  var runlist = this.every && this.every.before ? [ this.every.before ].concat(_flatten(fns)) : _flatten(fns);\n  if (this.every && this.every.on) {\n    runlist.push(this.every.on);\n  }\n  runlist.captures = fns.captures;\n  runlist.source = fns.source;\n  return runlist;\n};\n\nRouter.prototype.mount = function(routes, path) {\n  if (!routes || typeof routes !== \"object\" || Array.isArray(routes)) {\n    return;\n  }\n  var self = this;\n  path = path || [];\n  if (!Array.isArray(path)) {\n    path = path.split(self.delimiter);\n  }\n  function insertOrMount(route, local) {\n    var rename = route, parts = route.split(self.delimiter), routeType = typeof routes[route], isRoute = parts[0] === \"\" || !self._methods[parts[0]], event = isRoute ? \"on\" : rename;\n    if (isRoute) {\n      rename = rename.slice((rename.match(new RegExp(\"^\" + self.delimiter)) || [ \"\" ])[0].length);\n      parts.shift();\n    }\n    if (isRoute && routeType === \"object\" && !Array.isArray(routes[route])) {\n      local = local.concat(parts);\n      self.mount(routes[route], local);\n      return;\n    }\n    if (isRoute) {\n      local = local.concat(rename.split(self.delimiter));\n      local = terminator(local, self.delimiter);\n    }\n    self.insert(event, local, routes[route]);\n  }\n  for (var route in routes) {\n    if (routes.hasOwnProperty(route)) {\n      insertOrMount(route, path.slice(0));\n    }\n  }\n};\n\n\n\n}( true ? exports : window));\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _main = __webpack_require__(1);\n\nvar _main2 = _interopRequireDefault(_main);\n\nvar _app = __webpack_require__(0);\n\nvar _app2 = _interopRequireDefault(_app);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nif (window.location.hostname === 'localhost') {\n\tvar linkEl = document.querySelector('link[href=\"./css/styles.css\"]');\n\tvar headEl = document.querySelector('head');\n\theadEl.removeChild(linkEl);\n}\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// js/bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6a2ee9dae6859546eac2","import {Router} from 'director/build/director'\n\n\n\nlet renderHomeTemplate = function(txt){\n  document.querySelector('#app-container')\n    .innerHTML = `\n      <h1>How to draw an owl</h1>\n      <p>A step by step guide how to draw an owl</p>\n      <footer>\n        <a href=\"#/step-1\">&#10095;</a>\n      </footer>\n    `\n}\n\nlet renderStep1 = function(txt){\n  console.log(\"????\")\n  document.querySelector('#app-container')\n    .innerHTML = `\n        <h1>Step 1</h1>\n        <p>Draw some circles</p>\n        <img src=\"/images/step-1.png\"/>\n        <footer>\n          <a href=\"#/step-2\">&#10095;</a>\n        </footer>\n      `\n}\n\nlet renderStep2 = function(txt){\n  document.querySelector('#app-container')\n    .innerHTML =`\n      <h1>Step 2</h1>\n      <p>Draw the rest of the fucking owl</p>\n      <img src=\"/images/step-2.png\"/>\n      <footer>\n        <a href=\"/\">&#10095;</a>\n      </footer>\n    `\n}\n\n\nlet render404 = function(txt){\n  document.querySelector('#app-container')\n    .innerHTML =`\n      <h1 class=\"error-page\">Sorry</h1>\n      <p>That page doesn't exist</p>\n      <footer>\n        <a href=\"/\">&#10224;</a>\n      </footer>\n    `\n}\n\nconst routes = {\n  '/step-1' : renderStep1,\n  '/step-2' : renderStep2,\n  '/' : renderHomeTemplate,\n  '/*' : render404\n}\n\n/*Routing */\nlet routerInstance = Router(routes)\nrouterInstance.setRoute(routerInstance.getRoute())\nrouterInstance.init('/')\n\n\n\n// WEBPACK FOOTER //\n// ./src/scripts/app.js","\n\n//\n// Generated on Tue Dec 16 2014 12:13:47 GMT+0100 (CET) by Charlie Robbins, Paolo Fragomeni & the Contributors (Using Codesurgeon).\n// Version 1.2.6\n//\n\n(function (exports) {\n\n/*\n * browser.js: Browser specific functionality for director.\n *\n * (C) 2011, Charlie Robbins, Paolo Fragomeni, & the Contributors.\n * MIT LICENSE\n *\n */\n\nvar dloc = document.location;\n\nfunction dlocHashEmpty() {\n  // Non-IE browsers return '' when the address bar shows '#'; Director's logic\n  // assumes both mean empty.\n  return dloc.hash === '' || dloc.hash === '#';\n}\n\nvar listener = {\n  mode: 'modern',\n  hash: dloc.hash,\n  history: false,\n\n  check: function () {\n    var h = dloc.hash;\n    if (h != this.hash) {\n      this.hash = h;\n      this.onHashChanged();\n    }\n  },\n\n  fire: function () {\n    if (this.mode === 'modern') {\n      this.history === true ? window.onpopstate() : window.onhashchange();\n    }\n    else {\n      this.onHashChanged();\n    }\n  },\n\n  init: function (fn, history) {\n    var self = this;\n    this.history = history;\n\n    if (!Router.listeners) {\n      Router.listeners = [];\n    }\n\n    function onchange(onChangeEvent) {\n      for (var i = 0, l = Router.listeners.length; i < l; i++) {\n        Router.listeners[i](onChangeEvent);\n      }\n    }\n\n    //note IE8 is being counted as 'modern' because it has the hashchange event\n    if ('onhashchange' in window && (document.documentMode === undefined\n      || document.documentMode > 7)) {\n      // At least for now HTML5 history is available for 'modern' browsers only\n      if (this.history === true) {\n        // There is an old bug in Chrome that causes onpopstate to fire even\n        // upon initial page load. Since the handler is run manually in init(),\n        // this would cause Chrome to run it twise. Currently the only\n        // workaround seems to be to set the handler after the initial page load\n        // http://code.google.com/p/chromium/issues/detail?id=63040\n        setTimeout(function() {\n          window.onpopstate = onchange;\n        }, 500);\n      }\n      else {\n        window.onhashchange = onchange;\n      }\n      this.mode = 'modern';\n    }\n    else {\n      //\n      // IE support, based on a concept by Erik Arvidson ...\n      //\n      var frame = document.createElement('iframe');\n      frame.id = 'state-frame';\n      frame.style.display = 'none';\n      document.body.appendChild(frame);\n      this.writeFrame('');\n\n      if ('onpropertychange' in document && 'attachEvent' in document) {\n        document.attachEvent('onpropertychange', function () {\n          if (event.propertyName === 'location') {\n            self.check();\n          }\n        });\n      }\n\n      window.setInterval(function () { self.check(); }, 50);\n\n      this.onHashChanged = onchange;\n      this.mode = 'legacy';\n    }\n\n    Router.listeners.push(fn);\n\n    return this.mode;\n  },\n\n  destroy: function (fn) {\n    if (!Router || !Router.listeners) {\n      return;\n    }\n\n    var listeners = Router.listeners;\n\n    for (var i = listeners.length - 1; i >= 0; i--) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1);\n      }\n    }\n  },\n\n  setHash: function (s) {\n    // Mozilla always adds an entry to the history\n    if (this.mode === 'legacy') {\n      this.writeFrame(s);\n    }\n\n    if (this.history === true) {\n      window.history.pushState({}, document.title, s);\n      // Fire an onpopstate event manually since pushing does not obviously\n      // trigger the pop event.\n      this.fire();\n    } else {\n      dloc.hash = (s[0] === '/') ? s : '/' + s;\n    }\n    return this;\n  },\n\n  writeFrame: function (s) {\n    // IE support...\n    var f = document.getElementById('state-frame');\n    var d = f.contentDocument || f.contentWindow.document;\n    d.open();\n    d.write(\"<script>_hash = '\" + s + \"'; onload = parent.listener.syncHash;<script>\");\n    d.close();\n  },\n\n  syncHash: function () {\n    // IE support...\n    var s = this._hash;\n    if (s != dloc.hash) {\n      dloc.hash = s;\n    }\n    return this;\n  },\n\n  onHashChanged: function () {}\n};\n\nvar Router = exports.Router = function (routes) {\n  if (!(this instanceof Router)) return new Router(routes);\n\n  this.params   = {};\n  this.routes   = {};\n  this.methods  = ['on', 'once', 'after', 'before'];\n  this.scope    = [];\n  this._methods = {};\n\n  this._insert = this.insert;\n  this.insert = this.insertEx;\n\n  this.historySupport = (window.history != null ? window.history.pushState : null) != null\n\n  this.configure();\n  this.mount(routes || {});\n};\n\nRouter.prototype.init = function (r) {\n  var self = this\n    , routeTo;\n  this.handler = function(onChangeEvent) {\n    var newURL = onChangeEvent && onChangeEvent.newURL || window.location.hash;\n    var url = self.history === true ? self.getPath() : newURL.replace(/.*#/, '');\n    self.dispatch('on', url.charAt(0) === '/' ? url : '/' + url);\n  };\n\n  listener.init(this.handler, this.history);\n\n  if (this.history === false) {\n    if (dlocHashEmpty() && r) {\n      dloc.hash = r;\n    } else if (!dlocHashEmpty()) {\n      self.dispatch('on', '/' + dloc.hash.replace(/^(#\\/|#|\\/)/, ''));\n    }\n  }\n  else {\n    if (this.convert_hash_in_init) {\n      // Use hash as route\n      routeTo = dlocHashEmpty() && r ? r : !dlocHashEmpty() ? dloc.hash.replace(/^#/, '') : null;\n      if (routeTo) {\n        window.history.replaceState({}, document.title, routeTo);\n      }\n    }\n    else {\n      // Use canonical url\n      routeTo = this.getPath();\n    }\n\n    // Router has been initialized, but due to the chrome bug it will not\n    // yet actually route HTML5 history state changes. Thus, decide if should route.\n    if (routeTo || this.run_in_init === true) {\n      this.handler();\n    }\n  }\n\n  return this;\n};\n\nRouter.prototype.explode = function () {\n  var v = this.history === true ? this.getPath() : dloc.hash;\n  if (v.charAt(1) === '/') { v=v.slice(1) }\n  return v.slice(1, v.length).split(\"/\");\n};\n\nRouter.prototype.setRoute = function (i, v, val) {\n  var url = this.explode();\n\n  if (typeof i === 'number' && typeof v === 'string') {\n    url[i] = v;\n  }\n  else if (typeof val === 'string') {\n    url.splice(i, v, s);\n  }\n  else {\n    url = [i];\n  }\n\n  listener.setHash(url.join('/'));\n  return url;\n};\n\n//\n// ### function insertEx(method, path, route, parent)\n// #### @method {string} Method to insert the specific `route`.\n// #### @path {Array} Parsed path to insert the `route` at.\n// #### @route {Array|function} Route handlers to insert.\n// #### @parent {Object} **Optional** Parent \"routes\" to insert into.\n// insert a callback that will only occur once per the matched route.\n//\nRouter.prototype.insertEx = function(method, path, route, parent) {\n  if (method === \"once\") {\n    method = \"on\";\n    route = function(route) {\n      var once = false;\n      return function() {\n        if (once) return;\n        once = true;\n        return route.apply(this, arguments);\n      };\n    }(route);\n  }\n  return this._insert(method, path, route, parent);\n};\n\nRouter.prototype.getRoute = function (v) {\n  var ret = v;\n\n  if (typeof v === \"number\") {\n    ret = this.explode()[v];\n  }\n  else if (typeof v === \"string\"){\n    var h = this.explode();\n    ret = h.indexOf(v);\n  }\n  else {\n    ret = this.explode();\n  }\n\n  return ret;\n};\n\nRouter.prototype.destroy = function () {\n  listener.destroy(this.handler);\n  return this;\n};\n\nRouter.prototype.getPath = function () {\n  var path = window.location.pathname;\n  if (path.substr(0, 1) !== '/') {\n    path = '/' + path;\n  }\n  return path;\n};\nfunction _every(arr, iterator) {\n  for (var i = 0; i < arr.length; i += 1) {\n    if (iterator(arr[i], i, arr) === false) {\n      return;\n    }\n  }\n}\n\nfunction _flatten(arr) {\n  var flat = [];\n  for (var i = 0, n = arr.length; i < n; i++) {\n    flat = flat.concat(arr[i]);\n  }\n  return flat;\n}\n\nfunction _asyncEverySeries(arr, iterator, callback) {\n  if (!arr.length) {\n    return callback();\n  }\n  var completed = 0;\n  (function iterate() {\n    iterator(arr[completed], function(err) {\n      if (err || err === false) {\n        callback(err);\n        callback = function() {};\n      } else {\n        completed += 1;\n        if (completed === arr.length) {\n          callback();\n        } else {\n          iterate();\n        }\n      }\n    });\n  })();\n}\n\nfunction paramifyString(str, params, mod) {\n  mod = str;\n  for (var param in params) {\n    if (params.hasOwnProperty(param)) {\n      mod = params[param](str);\n      if (mod !== str) {\n        break;\n      }\n    }\n  }\n  return mod === str ? \"([._a-zA-Z0-9-%()]+)\" : mod;\n}\n\nfunction regifyString(str, params) {\n  var matches, last = 0, out = \"\";\n  while (matches = str.substr(last).match(/[^\\w\\d\\- %@&]*\\*[^\\w\\d\\- %@&]*/)) {\n    last = matches.index + matches[0].length;\n    matches[0] = matches[0].replace(/^\\*/, \"([_.()!\\\\ %@&a-zA-Z0-9-]+)\");\n    out += str.substr(0, matches.index) + matches[0];\n  }\n  str = out += str.substr(last);\n  var captures = str.match(/:([^\\/]+)/ig), capture, length;\n  if (captures) {\n    length = captures.length;\n    for (var i = 0; i < length; i++) {\n      capture = captures[i];\n      if (capture.slice(0, 2) === \"::\") {\n        str = capture.slice(1);\n      } else {\n        str = str.replace(capture, paramifyString(capture, params));\n      }\n    }\n  }\n  return str;\n}\n\nfunction terminator(routes, delimiter, start, stop) {\n  var last = 0, left = 0, right = 0, start = (start || \"(\").toString(), stop = (stop || \")\").toString(), i;\n  for (i = 0; i < routes.length; i++) {\n    var chunk = routes[i];\n    if (chunk.indexOf(start, last) > chunk.indexOf(stop, last) || ~chunk.indexOf(start, last) && !~chunk.indexOf(stop, last) || !~chunk.indexOf(start, last) && ~chunk.indexOf(stop, last)) {\n      left = chunk.indexOf(start, last);\n      right = chunk.indexOf(stop, last);\n      if (~left && !~right || !~left && ~right) {\n        var tmp = routes.slice(0, (i || 1) + 1).join(delimiter);\n        routes = [ tmp ].concat(routes.slice((i || 1) + 1));\n      }\n      last = (right > left ? right : left) + 1;\n      i = 0;\n    } else {\n      last = 0;\n    }\n  }\n  return routes;\n}\n\nvar QUERY_SEPARATOR = /\\?.*/;\n\nRouter.prototype.configure = function(options) {\n  options = options || {};\n  for (var i = 0; i < this.methods.length; i++) {\n    this._methods[this.methods[i]] = true;\n  }\n  this.recurse = options.recurse || this.recurse || false;\n  this.async = options.async || false;\n  this.delimiter = options.delimiter || \"/\";\n  this.strict = typeof options.strict === \"undefined\" ? true : options.strict;\n  this.notfound = options.notfound;\n  this.resource = options.resource;\n  this.history = options.html5history && this.historySupport || false;\n  this.run_in_init = this.history === true && options.run_handler_in_init !== false;\n  this.convert_hash_in_init = this.history === true && options.convert_hash_in_init !== false;\n  this.every = {\n    after: options.after || null,\n    before: options.before || null,\n    on: options.on || null\n  };\n  return this;\n};\n\nRouter.prototype.param = function(token, matcher) {\n  if (token[0] !== \":\") {\n    token = \":\" + token;\n  }\n  var compiled = new RegExp(token, \"g\");\n  this.params[token] = function(str) {\n    return str.replace(compiled, matcher.source || matcher);\n  };\n  return this;\n};\n\nRouter.prototype.on = Router.prototype.route = function(method, path, route) {\n  var self = this;\n  if (!route && typeof path == \"function\") {\n    route = path;\n    path = method;\n    method = \"on\";\n  }\n  if (Array.isArray(path)) {\n    return path.forEach(function(p) {\n      self.on(method, p, route);\n    });\n  }\n  if (path.source) {\n    path = path.source.replace(/\\\\\\//ig, \"/\");\n  }\n  if (Array.isArray(method)) {\n    return method.forEach(function(m) {\n      self.on(m.toLowerCase(), path, route);\n    });\n  }\n  path = path.split(new RegExp(this.delimiter));\n  path = terminator(path, this.delimiter);\n  this.insert(method, this.scope.concat(path), route);\n};\n\nRouter.prototype.path = function(path, routesFn) {\n  var self = this, length = this.scope.length;\n  if (path.source) {\n    path = path.source.replace(/\\\\\\//ig, \"/\");\n  }\n  path = path.split(new RegExp(this.delimiter));\n  path = terminator(path, this.delimiter);\n  this.scope = this.scope.concat(path);\n  routesFn.call(this, this);\n  this.scope.splice(length, path.length);\n};\n\nRouter.prototype.dispatch = function(method, path, callback) {\n  var self = this, fns = this.traverse(method, path.replace(QUERY_SEPARATOR, \"\"), this.routes, \"\"), invoked = this._invoked, after;\n  this._invoked = true;\n  if (!fns || fns.length === 0) {\n    this.last = [];\n    if (typeof this.notfound === \"function\") {\n      this.invoke([ this.notfound ], {\n        method: method,\n        path: path\n      }, callback);\n    }\n    return false;\n  }\n  if (this.recurse === \"forward\") {\n    fns = fns.reverse();\n  }\n  function updateAndInvoke() {\n    self.last = fns.after;\n    self.invoke(self.runlist(fns), self, callback);\n  }\n  after = this.every && this.every.after ? [ this.every.after ].concat(this.last) : [ this.last ];\n  if (after && after.length > 0 && invoked) {\n    if (this.async) {\n      this.invoke(after, this, updateAndInvoke);\n    } else {\n      this.invoke(after, this);\n      updateAndInvoke();\n    }\n    return true;\n  }\n  updateAndInvoke();\n  return true;\n};\n\nRouter.prototype.invoke = function(fns, thisArg, callback) {\n  var self = this;\n  var apply;\n  if (this.async) {\n    apply = function(fn, next) {\n      if (Array.isArray(fn)) {\n        return _asyncEverySeries(fn, apply, next);\n      } else if (typeof fn == \"function\") {\n        fn.apply(thisArg, (fns.captures || []).concat(next));\n      }\n    };\n    _asyncEverySeries(fns, apply, function() {\n      if (callback) {\n        callback.apply(thisArg, arguments);\n      }\n    });\n  } else {\n    apply = function(fn) {\n      if (Array.isArray(fn)) {\n        return _every(fn, apply);\n      } else if (typeof fn === \"function\") {\n        return fn.apply(thisArg, fns.captures || []);\n      } else if (typeof fn === \"string\" && self.resource) {\n        self.resource[fn].apply(thisArg, fns.captures || []);\n      }\n    };\n    _every(fns, apply);\n  }\n};\n\nRouter.prototype.traverse = function(method, path, routes, regexp, filter) {\n  var fns = [], current, exact, match, next, that;\n  function filterRoutes(routes) {\n    if (!filter) {\n      return routes;\n    }\n    function deepCopy(source) {\n      var result = [];\n      for (var i = 0; i < source.length; i++) {\n        result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];\n      }\n      return result;\n    }\n    function applyFilter(fns) {\n      for (var i = fns.length - 1; i >= 0; i--) {\n        if (Array.isArray(fns[i])) {\n          applyFilter(fns[i]);\n          if (fns[i].length === 0) {\n            fns.splice(i, 1);\n          }\n        } else {\n          if (!filter(fns[i])) {\n            fns.splice(i, 1);\n          }\n        }\n      }\n    }\n    var newRoutes = deepCopy(routes);\n    newRoutes.matched = routes.matched;\n    newRoutes.captures = routes.captures;\n    newRoutes.after = routes.after.filter(filter);\n    applyFilter(newRoutes);\n    return newRoutes;\n  }\n  if (path === this.delimiter && routes[method]) {\n    next = [ [ routes.before, routes[method] ].filter(Boolean) ];\n    next.after = [ routes.after ].filter(Boolean);\n    next.matched = true;\n    next.captures = [];\n    return filterRoutes(next);\n  }\n  for (var r in routes) {\n    if (routes.hasOwnProperty(r) && (!this._methods[r] || this._methods[r] && typeof routes[r] === \"object\" && !Array.isArray(routes[r]))) {\n      current = exact = regexp + this.delimiter + r;\n      if (!this.strict) {\n        exact += \"[\" + this.delimiter + \"]?\";\n      }\n      match = path.match(new RegExp(\"^\" + exact));\n      if (!match) {\n        continue;\n      }\n      if (match[0] && match[0] == path && routes[r][method]) {\n        next = [ [ routes[r].before, routes[r][method] ].filter(Boolean) ];\n        next.after = [ routes[r].after ].filter(Boolean);\n        next.matched = true;\n        next.captures = match.slice(1);\n        if (this.recurse && routes === this.routes) {\n          next.push([ routes.before, routes.on ].filter(Boolean));\n          next.after = next.after.concat([ routes.after ].filter(Boolean));\n        }\n        return filterRoutes(next);\n      }\n      next = this.traverse(method, path, routes[r], current);\n      if (next.matched) {\n        if (next.length > 0) {\n          fns = fns.concat(next);\n        }\n        if (this.recurse) {\n          fns.push([ routes[r].before, routes[r].on ].filter(Boolean));\n          next.after = next.after.concat([ routes[r].after ].filter(Boolean));\n          if (routes === this.routes) {\n            fns.push([ routes[\"before\"], routes[\"on\"] ].filter(Boolean));\n            next.after = next.after.concat([ routes[\"after\"] ].filter(Boolean));\n          }\n        }\n        fns.matched = true;\n        fns.captures = next.captures;\n        fns.after = next.after;\n        return filterRoutes(fns);\n      }\n    }\n  }\n  return false;\n};\n\nRouter.prototype.insert = function(method, path, route, parent) {\n  var methodType, parentType, isArray, nested, part;\n  path = path.filter(function(p) {\n    return p && p.length > 0;\n  });\n  parent = parent || this.routes;\n  part = path.shift();\n  if (/\\:|\\*/.test(part) && !/\\\\d|\\\\w/.test(part)) {\n    part = regifyString(part, this.params);\n  }\n  if (path.length > 0) {\n    parent[part] = parent[part] || {};\n    return this.insert(method, path, route, parent[part]);\n  }\n  if (!part && !path.length && parent === this.routes) {\n    methodType = typeof parent[method];\n    switch (methodType) {\n     case \"function\":\n      parent[method] = [ parent[method], route ];\n      return;\n     case \"object\":\n      parent[method].push(route);\n      return;\n     case \"undefined\":\n      parent[method] = route;\n      return;\n    }\n    return;\n  }\n  parentType = typeof parent[part];\n  isArray = Array.isArray(parent[part]);\n  if (parent[part] && !isArray && parentType == \"object\") {\n    methodType = typeof parent[part][method];\n    switch (methodType) {\n     case \"function\":\n      parent[part][method] = [ parent[part][method], route ];\n      return;\n     case \"object\":\n      parent[part][method].push(route);\n      return;\n     case \"undefined\":\n      parent[part][method] = route;\n      return;\n    }\n  } else if (parentType == \"undefined\") {\n    nested = {};\n    nested[method] = route;\n    parent[part] = nested;\n    return;\n  }\n  throw new Error(\"Invalid route context: \" + parentType);\n};\n\n\n\nRouter.prototype.extend = function(methods) {\n  var self = this, len = methods.length, i;\n  function extend(method) {\n    self._methods[method] = true;\n    self[method] = function() {\n      var extra = arguments.length === 1 ? [ method, \"\" ] : [ method ];\n      self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));\n    };\n  }\n  for (i = 0; i < len; i++) {\n    extend(methods[i]);\n  }\n};\n\nRouter.prototype.runlist = function(fns) {\n  var runlist = this.every && this.every.before ? [ this.every.before ].concat(_flatten(fns)) : _flatten(fns);\n  if (this.every && this.every.on) {\n    runlist.push(this.every.on);\n  }\n  runlist.captures = fns.captures;\n  runlist.source = fns.source;\n  return runlist;\n};\n\nRouter.prototype.mount = function(routes, path) {\n  if (!routes || typeof routes !== \"object\" || Array.isArray(routes)) {\n    return;\n  }\n  var self = this;\n  path = path || [];\n  if (!Array.isArray(path)) {\n    path = path.split(self.delimiter);\n  }\n  function insertOrMount(route, local) {\n    var rename = route, parts = route.split(self.delimiter), routeType = typeof routes[route], isRoute = parts[0] === \"\" || !self._methods[parts[0]], event = isRoute ? \"on\" : rename;\n    if (isRoute) {\n      rename = rename.slice((rename.match(new RegExp(\"^\" + self.delimiter)) || [ \"\" ])[0].length);\n      parts.shift();\n    }\n    if (isRoute && routeType === \"object\" && !Array.isArray(routes[route])) {\n      local = local.concat(parts);\n      self.mount(routes[route], local);\n      return;\n    }\n    if (isRoute) {\n      local = local.concat(rename.split(self.delimiter));\n      local = terminator(local, self.delimiter);\n    }\n    self.insert(event, local, routes[route]);\n  }\n  for (var route in routes) {\n    if (routes.hasOwnProperty(route)) {\n      insertOrMount(route, path.slice(0));\n    }\n  }\n};\n\n\n\n}(typeof exports === \"object\" ? exports : window));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/director/build/director.js\n// module id = 2\n// module chunks = 0","if(window.location.hostname === 'localhost'){\n\tlet linkEl = document.querySelector('link[href=\"./css/styles.css\"]')\n\tlet headEl = document.querySelector('head')\n\theadEl.removeChild(linkEl)\n}\n\nimport styles from './styles/main.scss'\nimport app from './scripts/app.js'\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}